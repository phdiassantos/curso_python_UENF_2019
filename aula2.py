# -*- coding: utf-8 -*-
"""aula2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/pedrosiracusa/curso_python_eamc/blob/master/notebooks/aula2.ipynb

# Aula 2. Estruturas de controle, Funções e Classes

##### Conteúdos

* [1. Estruturas de Controle](#1.-Estruturas-de-Controle)
    * [Estruturas Condicionais](#Estruturas-Condicionais)
    * [Estruturas de Repetição](#Estruturas-de-Repetição)
* [2. Funções](#2.-Funções)
    * [Definindo funções](#Definindo-funções)
    * [Funções Anônimas (*lambda*)](#Funções-Anônimas,-ou-Lambda)
* [3. Classes](#3.-Classes)

# 1. Estruturas de Controle

Estruturas de controle alteram a sequência em que instruções são executadas em um programa.
Aqui estudaremos as **estruturas condicionais** e **estruturas de repetição**.

## Estruturas Condicionais

Estruturas condicionais permitem alterar o fluxo de execução de um programa através da verificação de **condições**, que podem ser codificadas em nosso programa por meio de **expressões lógicas** (aquelas cuja avaliação resulta em valores do tipo **booleano**: `True` ou `False`).
Podemos construir estruturas condicionais com diferentes níveis de complexidade, dependendo do conjunto de condições.
Vejamos como construí-las

#### A construção *if*

A construção `if` é a maneira mais simples de escrevermos um bloco de código $A$ que somente deve ser executado caso uma determinada condição **seja satisfeita** (ou seja, avaliada como `True`). Caso contrário, o código $A$ é simplesmente ignorado

<img src="img/conditionals_if.png" width=450/>
"""

print("Antes da condicional: sempre executa")

cond = True

if cond:
    print("Código A: só executa caso a condição seja verdadeira")

print("Após a condicional: sempre executa")

"""#### A construção *if else*

Um `if` pode ser associado a um `else`, contendo um bloco de código que é executado caso a condição do `if` **não seja satisfeita** (ou seja, avaliada como `False`). Assim como no exemplo anterior, o código $A$ é executado caso a condição seja verdadeira. A diferença é que, no caso de a condição ser falsa, um código alternativo $B$ será executado

<img src="img/conditionals_ifelse.png" width=450/>
"""

print("Antes da condicional: sempre executa")

cond = True

if cond:
    print("Código A: só executa caso a condição seja verdadeira")
else:
    print("Código B: só executa caso a condição seja falsa")

print("Após a condicional: sempre executa")

"""As duas construções tratadas acima se baseiam na verificação de **apenas uma condição**, que dependendo de como for avaliada (`True` ou `False`), desencadeia um dentre dois possíveis comportamentos. 
Mas e se desejarmos construir uma estrutura condicional que permita **mais do que apenas dois "caminhos" diferentes**? 
Neste caso precisamos verificar mais do que uma única condição. Para isso precisamos usar estruturas condicionais aninhadas

#### Condicionais aninhadas

A primeira forma de incluir mais mais do que uma condição a ser testada na estrutura condicional é por **aninhamento**. Como resultado, teremos uma estrutura hierárquica, em que a execução de uma segunda condição depende do resultado de uma primeira condição. 
Não há limites para o número de níveis hierárquicos em uma estrutura condicional, apesar de que muitos níveis hierárquicos podem tornar o código mais difícil de entender.

**<span style="color:red">Cuidado!</span>** Em *Python* é fundamental respeitar o nível de indentação dos blocos de código em cada nível hierárquico!

<img src="img/conditionals_nested.png" width=600/>
"""

print("Antes da condicional: sempre executa")

cond1 = True
cond2 = True

if cond1:
    print("Código A: só executa caso a condição 1 seja verdadeira (não importa a condição 2)")
else:
    if cond2:
        print("Código B: só executa caso a condição 2 seja verdadeira (condição 1 foi falsa)")
    else:
        print("Código C: só executa caso a condição 2 seja falsa (condição 1 foi falsa)")

print("Após a condicional: sempre executa")

"""#### A construção *if elif else*

Uma sequência de vários `if` e `else` aninhados pode inserir muitos níveis de indentação no código, tornando-o confuso. Para evitar este problema, usamos a construção podemos inserir novas condições a serem verificadas usando a palavra `elif`. Pense no `elif` como uma fusão entre um  `else` e um `if`. O `else` no final captura qualquer caso em que nenhuma das condições anteriores foram satisfeitas.

O código das condicionais aninhadas na célula acima pode ser reescrito usando um `elif`. Note que agora toda a estrutura condicional está no mesmo nível de indentação!
"""

print("Antes da condicional: sempre executa")

cond1 = True
cond2 = True

if cond1:
    print("Código A: só executa caso a condição 1 seja verdadeira (não importa a condição 2)")
elif cond2:
    print("Código B: só executa caso a condição 2 seja verdadeira (condição 1 foi falsa)")
else:
    print("Código C: só executa caso a condição 2 seja falsa (condição 1 foi falsa)")

print("Após a condicional: sempre executa")

"""## Estruturas de Repetição

Estruturas de repetição nos permitem realizar tarefas repetitivas, potencializando o nível de **automação** em nossos programas.
**Loops** (em português "laços de repetição") são estruturas que garantem que determinada parte do código seja repetida várias vezes. 
Existem dois tipos fundamentais de loops: (i) ***for* loops** e (ii) ***while* loops**

### Loops do tipo "*for*"

Loops do tipo "**for**" permitem percorrer um objeto iterável (como uma lista, uma tupla ou uma *range*) sequencialmente. Tipicamente, usamos loops do tipo "*for*" quando já sabemos, *a priori*, o número de iterações. Sua estrutura é composta por:

* uma **variável de iteração** (normalmente chamada `i` ou `j`, mas poderia receber qualquer outro nome);
* a **lista** ou objeto iterável.

Percorrendo uma lista
"""

lista = ['a','b','c','d','e','f']

for i in lista:
    print(f"Nova iteração: elemento {i}")

"""Percorrendo uma *range*"""

for i in range(1,11):
    print(f"Nova iteração: elemento {i}")

"""Percorrendo elementos em um dicionário."""

dicio = { 'k1':'val1', 'k2':'val2', 'k3':'val3','k4':'val4', 'k5':'val5' }

for k,v in dicio.items():
    print(f"Nova iteração: chave {k} --> valor {v}")

"""**Obs 1.** O método `items` fornece uma lista de 2-tuplas, cada uma contendo uma chave e seu valor, respectivamente.

**Dica.** *Sequence unpacking*

Quando escrevemos `k,v` no lugar da variável de iteração, estamos associando cada chave a uma variável de nome `k` e cada valor a uma variável de nome `v`. Esta forma de associar as variáveis se chama [*sequence unpacking*](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences).
Ela funciona tanto para objetos iteráveis, em geral (listas, tuplas, ranges). No entanto, é necessário que o número de variáveis seja igual ao número de elementos dentro do objeto
"""

var1, var2 = ( 'a', 'b' )

print(f"var1 recebe {var1}")
print(f"var2 recebe {var2}")

"""**Dica.** *Enumerating*

Podemos também usar a função `enumerate` para obter o índice de cada elemento na lista, além de seu valor. A cada iteração, o índice do elemento e o valor são retornados como uma 2-tupla
"""

lista = ['a','b','c','d','e','f']

for i,el in enumerate(lista):
    print(f"Nova iteração (índice {i}): elemento {el}")

"""### Loops do tipo "*while*"

Loops do tipo *while* permitem continuar um loop enquanto determinada condição é satisfeita. São mais adequados nos casos em que não conseguimos determinar, *a priori*, o número total de iterações a serem realizadas.

Em loops do tipo "*while*", normalmente usamos uma variável de controle, como uma **variável contadora** (normalmente chamada `cntr`). Esta variável de controle deve ser atualizada a cada iteração!
"""

cntr = 0

while cntr < 10:
    print(f"Nova iteração. Variável contadora tem valor {cntr}")
    cntr = cntr + 1

"""Podemos também percorrer uma lista com um loop "*while*", embora neste caso o "*for*" seja mais adequado.
Neste caso, a condição é que entramos em um novo loop sempre que o índice (`i`) for menor que o comprimento da lista (`len(lista)`).
O índice `i` começa em 0 e é incrementado a cada loop
"""

lista = ['a','b','c','d','e','f']
i = 0

while i < len(lista):
    print(f"Nova iteração: Elemento {lista[i]} (índice {i})")
    i = i + 1

"""**<span style="color:red">Cuidado!</span>** Loops do tipo "*while*" podem originar **loops infinitos**, caso a condição do loop seja atualizada. Isso normalmente ocorre quando o programador se esquece de atualizar ou mesmo incluir a variável de controle."""

# Atenção: esta célula gera um loop infinito. Para finalizá-lo, clique no botão "pause", na barra de ferramentas
cond=True

while cond:
    print("Nova iteração")

"""---

# 2. Funções

Funções são construções que **encapsulam** um determinado comportamento que se espera executar múltiplas vezes durante a execução de um programa.
São rotinas, que podem ter sido definidas pelo próprio programador ou por outros programadores, cujos detalhes da implementação são abstraídos para o usuário.
O usuário portanto só precisa saber o que precisa saber como operar a função: que tipos de coisas deve fornecer como **entrada** (*input*) e o que deve esperar receber como **saída** (*output*)

<img src="img/functions.png">

Funções facilitam sua vida por dois motivos principais. 

1. Permitem ao programador **abstrair** computações, sem precisar se preocupar a todo momento sobre os mínimos detalhes de como elas são de fato realizadas. Imagine se você tivesse que se preocupar com os detalhes sobre como um texto é imprimido na tela de seu computador toda vez que você precisasse desta funcionalidade... Felizmente a função `print` permite que esta rotina seja abstraída para você, o que torna seu trabalho muito mais fluido! 

2. Permitem **compartilhar** e **reutilizar** código. Se você construir uma função que possa ajudar outras pessoas também, por que não compartilhar? Isso acontece bastante na comunidade de programadores, e os ajuda a não ficar "reinventando a roda" quando precisam de alguma funcionalidade que já foi implementada por alguém.

Para começar a entender como trabalhar com funções em *Python*, precisamos conhecer seus três componentes principais: *(i)* **nome**, *(ii)* **parâmetros** e *(iii)* **corpo**.

Dar um **nome** às funções é uma forma simples de mantermos uma referência a elas. Embora possamos nomear funções conforme nossa vontade, é recomendável escolhermos nomes que nos digam algo sobre seu funcionamento. É fácil lembrar que a função `print`, por exemplo, serve para imprimir algo na tela.

Os **parâmetros** fornecem um meio para "afinarmos" o comportamento de uma função para nossas necessidades. Os dados de entrada (*inputs*) são também passados para as funções através de parâmetros. No jargão da programação, nos referimos aos valores mapeados para cada um dos parâmetros como **argumentos**. Pense em um parâmetro como um *placeholder* para um valor, enquanto o argumento é o valor em si, passado para dentro da função através de um parâmetro.

Por fim, no **corpo** da função especificamos todas as etapas que devem ser realizadas por ela. Estas etapas incluem o processamento dos dados de entrada (*inputs*) e a construção do resultado que ela produzirá como saída (*output*). Lembre-se: no fim das contas, a ideia é que as computações descritas no corpo da função sejam abstraídas para o usuário da função.

## Definindo funções

Para definir (criar) uma nova função precisamos obedecer à seguinte sintaxe:
* a palavra `def` indica que uma nova função está sendo definida;
* após `def`, deve ser escrito o **nome** da função;
* após o nome da função, entre parênteses, os **parâmetros** são separados por vírgulas;
* Os dois pontos `:` após os parênteses indica que o **corpo** da função vem a seguir, no bloco de código abaixo. Ele contém todas as instruções (ou algoritmo) que determinam como a função se comporta;
* No fim do corpo da função, o valor de saída (*output*) é indicado após a palavra `return`.

**<span style="color:red">Cuidado!</span>** 
O bloco de código deve ser escrito com uma **indentação**, que é o distanciamento em relação à margem esquerda da célula

```python
def nome_funcao(par1, par2):
    instrucao_1
    instrucao_2
    instrucao_3
    return resultado
```

Para demonstrar como definir funções em *Python*, vamos começar com alguns exemplos bastante simples.
As funções a seguir apenas imprimem mensagens no console.

Podemos declarar funções sem parâmetros
"""

def foo():
    print("Função `foo` foi executada")
    print("Como não há parâmetros, o comportamento da função sempre será o mesmo")

foo()

"""com apenas um parâmetro"""

def bar(par1):
    print("Função `bar` foi executada")
    print(f"Parâmetro par1 recebe {par1} como valor (argumento)")

bar('Santos')

"""ou com múltiplos parâmetros"""

def baz(par1, par2):
    print("Função `baz` foi executada")
    print(f"Parâmetro par1 recebe argumento {par1}")
    print(f"Parâmetro par2 recebe argumento {par2}")

baz('Santos','Dumont')

"""Podemos especificar um valor *default* para os parâmetros, que será usado caso o usuário não forneça outro"""

def baz2(par1, par2="Barney"):
    print("Função `baz2` foi executada")
    print(f"Parâmetro par1 recebe argumento {par1}")
    print(f"Parâmetro par2 recebe argumento {par2}")

baz2('Santos')

baz2('Santos', 'Dumont')

"""Podemos também passar os argumentos fora de ordem, desde que especifiquemos a quais parâmetros eles devem ser mapeados"""

baz2(par2="Dumont", par1="Santos")

"""## Retornos de funções

As funções que vimos acima apenas imprimem mensagens no console.
Mas normalmente esperamos que funções retornem os resultados de suas computações como valores, que podem ser associados a variáveis e utilizados em computações subsequentes.
Vamos ver como retornar resultados de funções usando a keyword `return`

Vamos construir uma função `adicao` que soma dois números e retorna o resultado
"""

def adicao(n1,n2):
    res = n1 + n2
    return res

adicao(3,7)

"""Da mesma forma, podemos construir funções que fazem subtração, multiplicação e divisão"""

def subtracao(n1,n2):
    res = n1 - n2
    return res

def multiplicacao(n1,n2):
    return n1 * n2

def divisao(n1,n2):
    return n1/n2

"""Cada uma dessas funções realiza uma determinada operação matemática com dois números `n1` e `n2` e retorna o resultado"""

a,b,c,d = 3,5,7,10

"""Vamos agora fazer as seguintes operações, usando apenas as funções que declaramos acima.
Primeiramente usaremos variáveis para armazenar os valores resultantes de cada operação:
1. `u` recebe o resultado da adição de `a` e `b`
2. `v` recebe o resultado da subtração entre `d` e `c`
3. `w` recebe o resultado da multiplicação de `u` e `v`
4. `x` recebe o resultado da divisão de `w` por 2
"""

u = adicao(a,b)
v = subtracao(d,c)
w = multiplicacao(u,v)
x = divisao(w,2)

"""Vamos verificar o valor final (em `x`)"""

x

"""Poderíamos também realizar todas estas etapas em apenas uma expressão, evitando usar variáveis intermediárias. 
Por definição, funções mais "internas", que são passadas como argumentos para outras, executam primeiro.
Seus valores retornados são passados como argumentos para funções mais "externas".
"""

divisao( multiplicacao( adicao(a,b), subtracao(d,c) ), 2)

"""No exemplo acima, as funções `adicao` e `subtracao` são as primeiras a serem avaliadas. Seus resultados são usados pela função `multiplicacao` que, por sua vez, tem seu resultado passado para a função `divisão`, que é a última a ser executada

## Funções Anônimas, ou *Lambda*

Funções *lambda* são consideradas funções anônimas, por não serem necessariamente associadas a um nome. São constituídas por uma única expressão.
Sua construção é simples: 

```python
lambda x p1,p2,p3: expressão
``` 

* A keyword `lambda` indica a criação de uma função *lambda*;
* O conjunto de **parâmetros** (`p1`, `p2`, `p3`), cada qual separado do próximo por uma vírgula, é inserido após a keyword `lambda`. São encerrados por dois-pontos(`:`);
* Após os dois-pontos (`:`), escrevemos uma expressão que irá compor o **corpo** da função. O valor retornado é o resultado da expressão, e portanto não usamos a keyword `return`

A grande vantagem é que podemos, em apenas uma linha, construir e executar pequenas funções, sem o passo intermediário de armazená-las em memória. 
Este comportamento fornece grande agilidade em alguns casos, como por exemplo quando precisamos fornecer funções como argumentos para outras funções.
Como veremos nas próximas aulas, é comum usarmos este recurso quando queremos aplicar uma função a um conjunto de dados (mais sobre isso nas próximas aulas)

Vamos construir uma função lambda com um único parâmetro `x`, cuja funcionalidade é exponenciar `x` à potência 2
"""

lambda x: x**2

"""Agora vamos, em uma linha, construir três variações destas funções e executá-las imediatamente. Perceba que as funções não permanecem em memória, e "desaparecem" assim que são executadas"""

(lambda x: x**2)(2)

(lambda x: x**3)(2)

(lambda x: x**4)(2)

"""Se quisermos, podemos também guardar uma função lambda em memória, bastando para isso associá-la a uma variável"""

exp2 = lambda x: x**2
exp3 = lambda x: x**3
exp4 = lambda x: x**4

print( exp2(2) )
print( exp3(2) )
print( exp4(2) )

"""Funções lambda não necessariamente precisam ter apenas um parâmetro! Vamos adicionar o parâmetro `p`, que indica a potência da exponenciação"""

exp = lambda x,p: x**p

print( exp(2,2) )
print( exp(2,3) )
print( exp(2,4) )

"""Inclusive, podemos fornecer argumentos por *default*"""

exp = lambda x,p=2: x**p

print( exp(2) ) # por default, a potência é 2
print( exp(2,2) )
print( exp(2,3) )
print( exp(2,4) )

"""---

# 3. Classes

O conceito de classe vem do paradigma de **programação orientada a objetos**. 
Como o nome diz, este paradigma se baseia na existência de **objetos**, elementos que são criados durante a execução do programa, que armazenam dados, possuem comportamentos pré-definidos e mantêm estado.
Os resultados da execução do programa são obtidos através de várias interações entre objetos distintos.

**Classes** permitem ao programador definir como cada tipo de objeto deve armazenar dados, bem como quais procedimentos é capaz de realizar.
A ideia é que objetos são criados (ou **instanciados**) com base em classes definidas pelo programador.
Elas especificam as instruções sobre como construir os objetos de determinado tipo através de **atributos** e **métodos**:

**Atributos** definem os dados que pertencem a objetos de determinado tipo. Embora os atributos sejam os mesmos para todos os objetos do mesmo tipo, os valores de cada atributo são diferentes para cada objeto individual (também referido como *instância*).

**Métodos**  definem os comportamentos de objetos de determinado tipo. Podem fornecer informação sobre o objeto (métodos "*getter*"), ou atualizar seus atributos (métodos "*setter*").

### Construindo objetos

Objetos são instanciados segundo o padrão especificado da classe.
Um método especial, chamado **construtor** (em python, seu nome é `__init__`), é o primeiro a ser executado durante a instanciação, e guarda as instruções para a construção do objeto.
Nele são definidos os valores para cada um dos atributos.

Vamos definir uma nova classe, chamada `Vehicle`, que especifica objetos que representam veículos.
O construtor `__init__` é o único método que deve ser necessariamente implementado na definição de qualquer classe.
Por enquanto a classe `Vehicle` possui apenas quatro atributos (`type`, `model`, `manufacturer` e `seat_capacity`), e não possui métodos
"""

class Vehicle:
    
    def __init__(self, type, model, manufacturer, seat_capacity):
        self.type = type
        self.model = model
        self.manufacturer = manufacturer
        self.seat_capacity = seat_capacity

"""**Obs.** a keyword `self` deve sempre ser o primeiro parâmetro de qualquer método definido dentro de uma classe.
Ela se refere ao objeto sendo instanciado, e precisa ser usada sempre que queremos resgatar ou atribuir valores aos atributos da instância.

Agora vamos criar dois veículos: um avião e um carro, ambos instâncias de `Vehicle`. Os objetos serão atribuídos às variáveis `myPlane` e `myCar`, respectivamente, para que possam ser referenciados posteriormente.
Como as instâncias são diferentes umas das outras, passamos para o construtor de cada uma os valores que devem ser estabelecidos como atributos, na forma de argumentos.
"""

myPlane = Vehicle('plane', "A320", "Airbus", 180)
myCar = Vehicle('car', model="Uno", manufacturer="Fiat", seat_capacity=5)

"""Usamos a notação de ponto (`.`) para acessar atributos e métodos de objetos. Podemos consultar os valores dos atributos"""

print( myPlane.type )
print( myPlane.manufacturer )
print( myPlane.model )
print( myPlane.seat_capacity )

print( myCar.type )
print( myCar.manufacturer )
print( myCar.model )
print( myCar.seat_capacity )

"""ou alterar diretamente os valores dos atributos (embora esta abordagem não seja recomendada)"""

myPlane.model = 'a321'

myPlane.model

"""### Consultando dados do objeto com métodos "*getter*"

Em programação orientada a objetos, uma boa prática é prevenir o acesso direto a atributos do objeto, de forma a manter o **encapsulamento de dados**. Assim, os atributos do objeto tornam-se privados, sendo apenas visíveis pelo próprio objeto. Uma vantagem direta desta abordagem é que assim evitamos que nosso código modifique os atributos inadvertidamente. Outra vantagem é que adicionamos uma camada de abstração ao objeto: não importa muito como a informação é representada internamente ao objeto, podemos processá-la antes de externalizá-la. 

Vamos então adicionar dois métodos *getter* à nossa classe `Vehicle`
"""

class Vehicle:
    
    def __init__(self, type, model, manufacturer, seat_capacity):
        self.type = type
        self.model = model
        self.manufacturer = manufacturer
        self.seat_capacity = seat_capacity
        
    # Getter methods
    
    def getModel(self):
        return f"{self.manufacturer} {self.model}"
        
    def getSeatCapacity(self):
        return self.seat_capacity

"""O método `getModel` retorna o modelo do veículo, após o nome do fabricante. 
O método `getNumPassengers` simplesmente retorna o numero de passageiros que o veículo comporta.
Note que decidimos não externalizar o tipo (atributo `type`) do veículo
"""

myPlane = Vehicle('plane', "A320", "Airbus", 180)
myCar = Vehicle('car', model="Uno", manufacturer="Fiat", seat_capacity=5)

print( myPlane.getModel() )
print( f"Cabem {myPlane.getSeatCapacity()} passageiros no {myPlane.getModel()}" )

print( myCar.getModel() )
print( f"Cabem {myCar.getSeatCapacity()} passageiros no {myCar.getModel()}" )

"""### Atualizando dados do objeto com métodos "*setter*"

Frequentemente precisamos atualizar valores de atributos de objetos.
Vamos adicionar à classe `Vehicle` a funcionalidade de embarcar e desembarcar passageiros.

Para isso, faremos algumas modificações:

1. Adicionamos um atributo `n_passengers_onboard`, que armazena o número de passageiros a bordo. Este atributo é inicializado com o valor zero. Ou seja, no momento em que o objeto é criado não há nenhum passageiro embarcado;

2. Adicionamos mais dois métodos "*getter*": `getNumPassengersOnboard` retorna o número de passageiros que se encontram a bordo do veículo; e `getNumSeatsAvailable` retorna o número de assentos ainda disponíveis;

3. Adicionamos três métodos "*setter*": `removeAllPassengers` remove todos os passageiros a bordo; `embarkPassengers` adiciona $n$ passageiros ao veículo, desde que haja espaço; `removePassengers` remove $n$ passageiros do veículo.
"""

class Vehicle:
    
    def __init__(self, type, model, manufacturer, seat_capacity):
        self.type = type
        self.model = model
        self.manufacturer = manufacturer
        self.seat_capacity = seat_capacity
        
        self.n_passengers_onboard = 0
        
    # Getter methods
    
    def getModel(self):
        return f"{self.manufacturer} {self.model}"
        
    def getSeatCapacity(self):
        return self.seat_capacity
    
    def getNumPassengersOnboard(self):
        return self.n_passengers_onboard
    
    def getNumSeatsAvailable(self):
        return self.seat_capacity - self.n_passengers_onboard
    
    # Setter methods
    
    def removeAllPassengers(self):
        self.n_passengers_onboard = 0
        
    def embarkPassengers(self, n_passengers_to_embark):
        
        available_seats = self.getNumSeatsAvailable()
        
        if available_seats >= n_passengers_to_embark:
            self.n_passengers_onboard += n_passengers_to_embark
            return f"Mais {n_passengers_to_embark} passageiros embarcados com sucesso!"
        
        else:
            return f"Impossível embarcar mais {n_passengers_to_embark} passageiros! Apenas {available_seats} assentos disponíveis."
        
    def removePassengers(self, n_passengers_to_remove):
        
        if n_passengers_to_remove <= self.n_passengers_onboard:
            self.n_passengers_onboard -= n_passengers_to_remove
            return f"Desembarcaram {n_passengers_to_remove} passageiros"
        
        elif self.n_passengers_onboard > 0:
            n_passengers_remaining = self.n_passengers_onboard
            self.removeAllPassengers()
            return f"Havia apenas {n_passengers_remaining} embarcados! Todos desembarcaram."
        
        else:
            return "Nenhum passageiro a bordo"

"""Vamos então recriar o avião e o carro, embarcar e desembarcar passageiros"""

myPlane = Vehicle('plane', "A320", "Airbus", 180)
myCar = Vehicle('car', "Uno", "Fiat", 5)

"""No avião:"""

print( myPlane.embarkPassengers(50) )
print( f"{myPlane.getNumPassengersOnboard()} passageiros a bordo" )
print( f"{myPlane.getNumSeatsAvailable()} assentos disponíveis" )

print(myPlane.removePassengers(5))
print( f"{myPlane.getNumPassengersOnboard()} passageiros a bordo" )
print( f"{myPlane.getNumSeatsAvailable()} assentos disponíveis" )

"""No carro:"""

print( myCar.embarkPassengers(5) )
print( f"{myCar.getNumPassengersOnboard()} passageiros a bordo" )
print( f"{myCar.getNumSeatsAvailable()} assentos disponíveis" )

print(myCar.removePassengers(5))
print( f"{myCar.getNumPassengersOnboard()} passageiros a bordo" )
print( f"{myCar.getNumSeatsAvailable()} assentos disponíveis" )

"""### Herança

Um conceito muito importante na programação orientada a objetos é a **herança** (*inheritance*).
**Subclasses** podem "herdar" comportamentos e atributos de sua **superclasse**, ou classe-pai.

Vamos criar duas novas subclasses, `Airplane` e `Car`, que são veículos mais "específicos".
Elas extendem a superclasse `Vehicle`, que é mais "genérica".
Alguns pontos importantes:

#### Construtores
As subclasses têm seus próprios métodos construtores (`__init__`), que não usam o argumento `type`. Isso porque o tipo da classe `Airplane` sempre será `'plane'`, enquanto o tipo da classe `Car` sempre será `'car'`. Este atributo, no entanto, é passado para o construtor da superclasse (`super().__init__`). Além disso, a classe `Airplane` espera um novo argumento `airline`, que guarda o nome da companhia aérea e, portanto, é um atributo exclusivo de aeronaves


#### Novos métodos e atributos
Subclasses podem ter métodos e atributos que não existiam em sua superclasse. No nosso exemplo, a classe `Airplane` possui o método `takeoff`, enquanto a classe `Car` possui o método `drive`. Não faria sentido um método chamado `takeoff` na classe `Vehicle`, pois nem todos os veículos podem decolar.
O atributo `airline`, também exclusivo da classe `Airplane`, também não faria sentido para outros veículos como carros ou barcos.

#### Substituição (*overriding*)
Um subclasse pode substituir o comportamento herdado de sua superclasse, através de um mecanismo chamado *overriding* (substituição, em português). Em *Python*, isso pode ser feito simplesmente reimplementando o método da superclasse. Na classe `Car`, por exemplo, o método `embarkPassengers` foi substituído, sendo adicionado o parâmetro `name_driver`, que deve receber o nome do motorista. Este comportamento portanto ocorre apenas em carros, e não substitui o comportamento do mesmo método na classe `Airplane` nem na classe `Vehicle`.
"""

class Airplane(Vehicle):
    def __init__(self, model, manufacturer, airline, seat_capacity):
        super().__init__(type='plane',model=model,manufacturer=manufacturer,seat_capacity=seat_capacity)
        self.airline = airline
        
    def takeoff(self):
        print(f"O {self.getModel()} da {self.airline} está decolando com {self.getNumPassengersOnboard()} passageiros")
        
        
        
        
        
class Car(Vehicle):
    def __init__(self, model, manufacturer, seat_capacity):
        super().__init__(type='car',model=model,manufacturer=manufacturer,seat_capacity=seat_capacity)
        
    def embarkPassengers(self, n_passengers_to_embark, name_driver):

            available_seats = self.getNumSeatsAvailable()
            self.name_driver = name_driver

            if available_seats >= n_passengers_to_embark:
                self.n_passengers_onboard += n_passengers_to_embark
                return f"Mais {n_passengers_to_embark} passageiros embarcados com sucesso!"

            else:
                return f"Impossível embarcar mais {n_passengers_to_embark} passageiros! Apenas {available_seats} assentos disponíveis."

        
    def drive(self):
        if self.getNumPassengersOnboard()>0:
            print(f"O {self.getModel()}, conduzido por {self.name_driver}, está na estrada com {self.getNumPassengersOnboard()} passageiros")

        else:
            print("Um carro não pode operar sem motorista!")

"""Vamos agora testar as subclasses"""

latamPlane = Airplane('A320','Airbus', "Latam", 180)

print(latamPlane.embarkPassengers(130))
latamPlane.takeoff()

azulPlane = Airplane('ERJ190','Embraer', "Azul", 100)

print(azulPlane.embarkPassengers(70))
azulPlane.takeoff()

myCar = Car('Uno','Fiat', 5)

print(myCar.embarkPassengers(3, name_driver="Sérgio"))
myCar.drive()